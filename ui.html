<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<meta name="color-scheme" content="dark light" />
<title>Grooky</title>
<style>
  :root { color-scheme: dark; }
  html, body { height:100% }
  body{
    margin:0; background:#0b0b0d; color:#e8e8ea;
    font-family:-apple-system, system-ui, "SF Pro Text", Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    display:flex; flex-direction:column; min-height:100%;
  }

  /* Header */
  header{
    display:flex; align-items:center; gap:12px; padding:10px 14px;
    border-bottom:1px solid #1b1b21; position:sticky; top:0; background:#0b0b0d; z-index:2;
  }
  .brand{ display:flex; align-items:center; gap:10px; }
  #grookyCanvas{
    width:30px; height:30px; border-radius:50%;
    box-shadow: 0 0 18px rgba(255,212,79,.25), 0 0 18px rgba(0,216,167,.18);
  }
  h1{ font-size:16px; margin:0; color:#dcdce4; letter-spacing:.2px }

  /* Chat */
  main{ flex:1; overflow:auto; padding:12px; }
  .msg{
    max-width:860px; margin:0 auto 8px auto; display:flex; flex-direction:column;
  }
  .bubble{
    background:#121217; border:1px solid #23232a; border-radius:12px;
    padding:8px 12px; line-height:1.42; white-space:pre-wrap; word-break:break-word;
  }
  /* Usuario a todo el ancho del hilo */
  .msg.user .bubble{ background:#0f1e27; border-color:#193545; width:100%; }
  .msg.assistant .bubble{ background:#14141b; border-color:#23232a; max-width:100%; }
  .who{
    font-size:11px; color:#98a0ae; margin:0 0 2px 2px; line-height:1;
  }
  .text{ /* contenedor del contenido de mensaje */ }
  .meta{
    display:flex; justify-content:flex-end; gap:8px;
    font-size:10.5px; color:#8b93a3; margin-top:4px; opacity:.9;
  }

  .typing { border-right:1px solid #79c0ff; animation: caret 1s steps(1) infinite; }
  @keyframes caret { 50% { border-color: transparent; } }

  /* Composer */
  form{
    display:flex; gap:8px; padding:10px; border-top:1px solid #1b1b21;
    background:#0b0b0d; position:sticky; bottom:0;
  }
  textarea{
    flex:1; resize:none; min-height:38px; max-height:120px; padding:9px 11px; border-radius:11px;
    border:1px solid #23232a; background:#121217; color:#e8e8ea; outline:none;
  }
  button{
    background:#26262f; color:#e8e8ea; border:1px solid #353542; border-radius:11px; padding:9px 12px; min-width:44px;
  }
  #mic{
    min-width:44px; padding:8px; display:grid; place-items:center;
  }
  #mic.rec{ background:#5e2345; border-color:#823157; }
  #mic svg{ width:18px; height:18px; opacity:.9 }

  /* Toast */
  .toast{
    position:fixed; left:50%; transform:translateX(-50%);
    bottom:18px; background:#1a1a1f; border:1px solid #2a2a32;
    color:#ddd; padding:8px 12px; border-radius:10px; font-size:14px;
  }

  /* Accesibilidad */
  @media (prefers-reduced-motion: reduce){
    .typing{ animation:none; border-right:none }
  }
</style>
</head>
<body>
  <header>
    <div class="brand">
      <!-- Orbe Grooky: ondas amarillo + verde‑azul -->
      <canvas id="grookyCanvas" width="60" height="60" aria-hidden="true"></canvas>
      <h1 id="title">Grooky</h1>
    </div>
  </header>

  <main id="chat" aria-live="polite"></main>

  <form id="form" autocomplete="off">
    <!-- Mic minimal con SVG -->
    <button id="mic" type="button" title="Dictar" aria-label="Dictar">
      <svg viewBox="0 0 24 24" fill="none" stroke="#e8e8ea" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 3a3 3 0 0 0-3 3v6a3 3 0 0 0 6 0V6a3 3 0 0 0-3-3z"/>
        <path d="M19 10a7 7 0 0 1-14 0"/>
        <path d="M12 17v4"/>
      </svg>
    </button>
    <textarea id="input" placeholder="Escribe o dicta…" rows="1"></textarea>
    <button id="send" type="submit" title="Enviar" aria-label="Enviar">Enviar</button>
  </form>

<script>
(() => {
  // ---------- Parámetros ----------
  const qs       = new URLSearchParams(location.search);
  const APIURL   = "/api/siri-gpt"; // mismo dominio
  const MODEL    = qs.get("model") || "llama-3.3-70b-versatile";

  // Caso 2: sembrar primer turno resuelto
  const INIT_U   = qs.get("u") || ""; // user
  const INIT_A   = qs.get("a") || ""; // assistant
  const TITLE    = qs.get("title") || "Grooky";
  const SPEED    = Math.max(1, parseInt(qs.get("speed") || "18", 10));
  const CHUNK    = Math.max(1, parseInt(qs.get("chunk") || "2", 10));
  const THREAD   = qs.get("id") || ("t_" + Math.random().toString(36).slice(2,10));
  const VOICE_L  = qs.get("voice") || "es-ES"; // idioma dictado (si disponible)

  document.getElementById("title").textContent = TITLE;

  // ---------- DOM ----------
  const $chat  = document.getElementById("chat");
  const $form  = document.getElementById("form");
  const $input = document.getElementById("input");
  const $send  = document.getElementById("send");
  const $mic   = document.getElementById("mic");

  // ---------- Historial ----------
  const KEY = "siri_ui_chat_" + THREAD;
  let history = loadHistory(); // incluye prompt de sistema [0]
  renderAll();

  // Sembrado: escribir con typing la primera respuesta (y guardar con timestamp)
  (async () => {
    if (INIT_U.trim() && INIT_A.trim()) {
      const now = Date.now();
      renderRow("user", INIT_U.trim(), now);
      const el = startTypingSkeleton();               // devolverá un elemento único (sin id global)
      await typewrite(el, INIT_A.trim(), SPEED, CHUNK);
      el.classList.remove("typing");
      el.textContent = INIT_A.trim();

      history.push({ role:"user", content: INIT_U.trim(), ts: now });
      history.push({ role:"assistant", content: INIT_A.trim(), ts: Date.now() });
      saveHistory();
    } else if (INIT_U.trim()) {
      $input.value = INIT_U.trim();
      autoResize();
      submitMessage();
    }
  })();

  // Envío por formulario
  $form.addEventListener("submit", (e) => {
    e.preventDefault();
    submitMessage();
  });

  // Auto‑resize del textarea
  $input.addEventListener("input", autoResize);

  // ---------- Mic / Dictado minimal ----------
  const supportsSR = "webkitSpeechRecognition" in window;
  if (!supportsSR) {
    $mic.addEventListener("click", () => {
      showToast("Dictado no disponible aquí. Abriendo en Safari…");
      const a = document.createElement("a");
      a.href = location.href; a.target = "_blank"; a.rel="noopener"; a.click();
    });
  } else {
    let rec;
    try { rec = new webkitSpeechRecognition(); } catch {}
    if (rec) {
      rec.lang = VOICE_L;
      rec.continuous = false;
      rec.interimResults = true;

      let finalText = "";
      rec.onstart  = () => { $mic.classList.add("rec"); showToast("Escuchando…"); };
      rec.onresult = (e) => {
        let interim = "";
        for (let i=0; i<e.results.length; i++){
          const r = e.results[i];
          if (r.isFinal) finalText += r[0].transcript;
          else interim += r[0].transcript;
        }
        $input.value = (finalText + interim).trim();
        autoResize();
      };
      rec.onerror = () => { $mic.classList.remove("rec"); showToast("No se pudo usar el dictado"); };
      rec.onend   = () => {
        $mic.classList.remove("rec");
        $input.value = finalText.trim() || $input.value.trim();
        autoResize();
        // Auto‑enviar al terminar de dictar (opcional):
        // if ($input.value.trim()) submitMessage();
      };

      $mic.addEventListener("click", () => {
        try { finalText = ""; rec.start(); } catch { /* ignore */ }
      });
    }
  }

  // ---------- Utilidades de formato ----------
  const fmt2 = n => (n<10 ? "0"+n : ""+n);
  function fmtTime(ts){
    const d = new Date(ts || Date.now());
    return `${fmt2(d.getHours())}:${fmt2(d.getMinutes())}`;
  }

  // ---------- UI / Historial ----------
  function loadHistory() {
    try {
      const raw = localStorage.getItem(KEY);
      if (raw) return JSON.parse(raw);
    } catch {}
    return [{ role: "system", content: "Eres un asistente útil y conciso.", ts: Date.now() }];
  }
  function saveHistory() {
    try { localStorage.setItem(KEY, JSON.stringify(history)); } catch {}
  }

  function renderRow(role, content, ts){
    const row = document.createElement("div");
    row.className = "msg " + (role === "user" ? "user" : "assistant");
    const time = fmtTime(ts);
    row.innerHTML = `
      <div class="bubble">
        <div class="who">${role === "user" ? "Tú" : "Grooky"}</div>
        <div class="text">${escapeHTML(content)}</div>
        <div class="meta">${time}</div>
      </div>`;
    $chat.appendChild(row);
    $chat.scrollTo({ top: $chat.scrollHeight });
    return row;
  }
  function addUser(text) {
    const ts = Date.now();
    renderRow("user", text, ts);
    history.push({ role: "user", content: text, ts });
    saveHistory();
  }
  function addAssistant(text) {
    const ts = Date.now();
    renderRow("assistant", text, ts);
    history.push({ role: "assistant", content: text, ts });
    saveHistory();
  }
  function renderAll(){
    $chat.innerHTML = "";
    for (const msg of history) {
      if (msg.role === "system") continue;
      renderRow(msg.role, msg.content, msg.ts);
    }
  }
  function startTypingSkeleton() {
    // Crea burbuja de Grooky + contenedor de texto con clase 'typing' y devuelve ese elemento,
    // para no usar ids globales (evita sobrescribir mensajes anteriores).
    const row = document.createElement("div");
    row.className = "msg assistant";
    const bubble = document.createElement("div");
    bubble.className = "bubble";
    const who = document.createElement("div");
    who.className = "who"; who.textContent = "Grooky";
    const text = document.createElement("div");
    text.className = "text typing"; // ← este es el que devolvemos
    const meta = document.createElement("div");
    meta.className = "meta"; meta.textContent = fmtTime(Date.now());
    bubble.appendChild(who); bubble.appendChild(text); bubble.appendChild(meta);
    row.appendChild(bubble);
    $chat.appendChild(row);
    $chat.scrollTo({ top: $chat.scrollHeight });
    return text; // elemento único
  }

  // ---------- Backend (turnos siguientes) ----------
  async function submitMessage() {
    const text = ($input.value || "").trim();
    if (!text) return;
    $input.value = "";
    autoResize();

    addUser(text);
    const typingEl = startTypingSkeleton();
    disable(true);

    try {
      const payload = { model: MODEL, messages: history };
      const r = await fetch(APIURL, {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify(payload)
      });
      const data = await r.json();
      if (!r.ok) throw new Error(data?.error || "Error de API");
      const reply = String(data.response || "");

      await typewrite(typingEl, reply, SPEED, CHUNK);
      typingEl.classList.remove("typing");
      typingEl.textContent = reply;

      history.push({ role:"assistant", content: reply, ts: Date.now() });
      saveHistory();

    } catch (err) {
      typingEl.classList.remove("typing");
      typingEl.textContent = "⚠️ " + (err?.message || "Fallo inesperado");
    } finally {
      disable(false);
    }
  }

  // ---------- Funciones comunes ----------
  function typewrite(targetEl, text, speed, chunk) {
    return new Promise(resolve => {
      let i = 0;
      const step = () => {
        if (i >= text.length) return resolve();
        targetEl.textContent += text.slice(i, i + chunk);
        i += chunk;
        setTimeout(step, speed);
      };
      step();
    });
  }
  function escapeHTML(s="") {
    return s.replace(/[&<>"]/g, ch => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;" }[ch]));
  }
  function disable(b) {
    $send.disabled = b;
    $input.disabled = b;
    $mic.disabled  = b;
  }
  function autoResize(){
    $input.style.height = "auto";
    $input.style.height = Math.min(120, $input.scrollHeight) + "px";
  }
  function showToast(msg){
    const t = document.createElement("div");
    t.className = "toast"; t.textContent = msg;
    document.body.appendChild(t);
    setTimeout(() => { t.remove(); }, 2000);
  }

  // ---------- Grooky canvas: ondas amarillo + verde‑azul ----------
  const cv = document.getElementById("grookyCanvas");
  const ctx = cv.getContext("2d");
  const DPR = Math.max(1, window.devicePixelRatio || 1);
  const W = 60, H = 60;
  cv.width = W * DPR; cv.height = H * DPR; ctx.scale(DPR, DPR);

  let t = 0;
  function draw(){
    ctx.clearRect(0,0,W,H);

    // Clip circular
    ctx.save();
    ctx.beginPath();
    ctx.arc(W/2, H/2, W/2, 0, Math.PI*2);
    ctx.clip();

    // Fondo suave
    const bg = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, W/2);
    bg.addColorStop(0, "rgba(255,213,79,0.15)");  // amarillo
    bg.addColorStop(1, "rgba(0,216,167,0.10)");   // verde‑azul
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,W,H);

    // Onda 1 (amarillo)
    wave("#FFD54F", 1.6, 0.020, t*1.1);
    // Onda 2 (verde‑azul)
    wave("#00D8A7", 1.3, 0.024, t*1.35 + 2.0);

    ctx.restore();

    // Glow exterior
    ctx.strokeStyle = "rgba(255,213,79,0.35)";
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(W/2, H/2, W/2-0.5, 0, Math.PI*2); ctx.stroke();

    t += 0.03;
    requestAnimationFrame(draw);
  }
  function wave(color, amp, freq, phase){
    ctx.beginPath();
    for (let x=0; x<=W; x++){
      const y = H/2
        + Math.sin(x*freq + phase) * (H/10)*amp
        + Math.sin(x*freq*0.5 + phase*0.7) * (H/20);
      x===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
    }
    ctx.lineWidth = 2;
    ctx.strokeStyle = color;
    ctx.stroke();
  }
  draw();
})();
</script>
</body>
</html>
